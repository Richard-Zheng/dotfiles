#!/bin/bash
# Modernized PulseAudio/PipeWire Volume Script for i3blocks

set -a

# Speaker Symbols
AUDIO_HIGH_SYMBOL=${AUDIO_HIGH_SYMBOL:-'  '}
AUDIO_MED_THRESH=${AUDIO_MED_THRESH:-50}
AUDIO_MED_SYMBOL=${AUDIO_MED_SYMBOL:-'  '}
AUDIO_LOW_THRESH=${AUDIO_LOW_THRESH:-0}
AUDIO_LOW_SYMBOL=${AUDIO_LOW_SYMBOL:-'  '}
AUDIO_MUTED_SYMBOL=${AUDIO_MUTED_SYMBOL:-'  '}

# Microphone Symbols
MIC_ON_SYMBOL=${MIC_ON_SYMBOL:-' '}
MIC_OFF_SYMBOL=${MIC_OFF_SYMBOL:-' '}

AUDIO_DELTA=${AUDIO_DELTA:-5}

DEFAULT_COLOR=${DEFAULT_COLOR:-"#ffffff"}
MUTED_COLOR=${MUTED_COLOR:-"#a0a0a0"}

LONG_FORMAT=${LONG_FORMAT:-'${SYMB} ${VOL}% [${NAME}]  ${MIC_SYMB} [${MIC_NAME}]'}
SHORT_FORMAT=${SHORT_FORMAT:-'${SYMB} ${VOL}%'}

SUBSCRIBE=${SUBSCRIBE:-0}

# ==========================================
# Core Function 1: Cycle Physical Devices (Cards)
# e.g., switch between Built-in Audio and Bluetooth
# ==========================================
cycle_cards() {
  local dir=${1:-1}

  # 1. Get all available cards
  local cards=($(pactl list cards short | awk '{print $2}'))
  if [ ${#cards[@]} -le 1 ]; then return; fi

  # 2. Find the current active card based on the default sink
  local default_sink=$(pactl get-default-sink)
  local current_card=$(pactl list sinks | awk -v sink="$default_sink" '
        $1 == "Name:" { found = ($2 == sink) }
        found && /^\s*device\.name =/ { gsub(/"/, "", $3); print $3; exit }
    ')

  if [ -z "$current_card" ]; then
    current_card=${cards[0]}
  fi

  # 3. Calculate the next card index
  local idx=0
  for i in "${!cards[@]}"; do
    if [[ "${cards[$i]}" == "$current_card" ]]; then
      idx=$i
      break
    fi
  done

  local next_idx=$(((idx + dir + ${#cards[@]}) % ${#cards[@]}))
  local next_card="${cards[$next_idx]}"

  # 4. Check if the next card is "off". If so, activate its first available output profile.
  local active_prof=$(pactl list cards | awk -v card="$next_card" '
        /^\s*Name: / { curr=$2 }
        curr == card && /^\s*Active Profile:/ { print $3; exit }
    ')

  if [[ "$active_prof" == "off" || -z "$active_prof" ]]; then
    local first_avail=$(pactl list cards | awk -v card="$next_card" '
            /^\s*Name: / { curr=$2 }
            curr == card { in_card=1 }
            /^\s*Profiles:/ { if(in_card) in_prof=1; next }
            /^\s*Active Profile:/ { if(in_card) in_prof=0; exit }
            in_prof && /sinks: [1-9]/ && !/available: no/ {
                prof=$1; sub(/:$/, "", prof); print prof; exit
            }
        ')
    if [[ -n "$first_avail" ]]; then
      pactl set-card-profile "$next_card" "$first_avail"
      sleep 0.2
    fi
  fi

  # 5. Find the active sink of the new card and move streams
  local new_sink=$(pactl list sinks | awk -v card="$next_card" '
        $1 == "Name:" { current_sink = $2 }
        /^\s*device\.name =/ { 
            gsub(/"/, "", $3); 
            if ($3 == card) { print current_sink; exit }
        }
    ')

  if [[ -n "$new_sink" ]]; then
    pactl set-default-sink "$new_sink"
    for input in $(pactl list sink-inputs short | awk '{print $1}'); do
      pactl move-sink-input "$input" "$new_sink" 2>/dev/null
    done
  fi
}

# ==========================================
# Core Function 2: Cycle Profiles on Current Card
# e.g., Built-in: Analog <-> HDMI | Bluez: A2DP <-> HSP
# ==========================================
cycle_profiles() {
  local dir=${1:-1}

  # 1. Identify the current card
  local default_sink=$(pactl get-default-sink)
  local current_card=$(pactl list sinks | awk -v sink="$default_sink" '
        $1 == "Name:" { found = ($2 == sink) }
        found && /^\s*device\.name =/ { gsub(/"/, "", $3); print $3; exit }
    ')
  if [ -z "$current_card" ]; then return; fi

  # 2. Get all available output profiles for THIS card only
  local combos=($(pactl list cards | awk -v target="$current_card" '
        /^\s*Name: / { card=$2 }
        /^\s*Profiles:/ { if(card == target) in_prof=1; next }
        /^\s*Active Profile:/ { if(card == target) in_prof=0 }
        in_prof && /sinks: [1-9]/ && !/available: no/ {
            prof=$1; sub(/:$/, "", prof); print prof
        }
    '))

  if [ ${#combos[@]} -le 1 ]; then return; fi

  local current_prof=$(pactl list cards | awk -v card="$current_card" '
        /^\s*Name: / { curr=$2 }
        curr == card && /^\s*Active Profile:/ { print $3; exit }
    ')

  # 3. Switch to the next profile
  local idx=0
  for i in "${!combos[@]}"; do
    if [[ "${combos[$i]}" == "$current_prof" ]]; then
      idx=$i
      break
    fi
  done

  local len=${#combos[@]}
  local next_idx=$(((idx + dir + len) % len))
  local next_prof="${combos[$next_idx]}"

  pactl set-card-profile "$current_card" "$next_prof"
  sleep 0.2

  # 4. Migrate audio streams to the new profile's sink
  local new_sink=$(pactl list sinks | awk -v card="$current_card" '
        $1 == "Name:" { current_sink = $2 }
        /^\s*device\.name =/ { 
            gsub(/"/, "", $3); 
            if ($3 == card) { print current_sink; exit }
        }
    ')

  if [[ -n "$new_sink" ]]; then
    pactl set-default-sink "$new_sink"
    for input in $(pactl list sink-inputs short | awk '{print $1}'); do
      pactl move-sink-input "$input" "$new_sink" 2>/dev/null
    done
  fi
}

# ==========================================
# Core Function 3: Safely adjust volume (max 100%)
# ==========================================
change_volume() {
  local action=$1
  local current_vol=$(pactl get-sink-volume @DEFAULT_SINK@ | grep -Po '\d+(?=%)' | head -n 1)

  if [[ -z "$current_vol" ]]; then return; fi

  if [[ "$action" == "up" ]]; then
    if ((current_vol + AUDIO_DELTA >= 100)); then
      pactl set-sink-volume @DEFAULT_SINK@ 100%
    else
      pactl set-sink-volume @DEFAULT_SINK@ +${AUDIO_DELTA}%
    fi
  elif [[ "$action" == "down" ]]; then
    pactl set-sink-volume @DEFAULT_SINK@ -${AUDIO_DELTA}%
  fi
}

# ==========================================
# CLI Interface for i3 config bindings
# ==========================================
case "$1" in
--up)
  change_volume up
  exit 0
  ;;
--down)
  change_volume down
  exit 0
  ;;
--mute)
  pactl set-sink-mute @DEFAULT_SINK@ toggle
  exit 0
  ;;
--mute-mic)
  pactl set-source-mute @DEFAULT_SOURCE@ toggle
  exit 0
  ;;
--cycle-card)
  cycle_cards 1
  exit 0
  ;;
--cycle-prof)
  cycle_profiles 1
  exit 0
  ;;
esac

# ==========================================
# Mouse click event handling
# ==========================================
case "$BLOCK_BUTTON" in
1) cycle_cards 1 ;;                                 # Left click: Cycle Devices (Cards)
2) cycle_profiles 1 ;;                              # Middle click: Cycle Profiles (HDMI/Analog/etc)
3) pactl set-source-mute @DEFAULT_SOURCE@ toggle ;; # Right click: Toggle Mic Mute
4) change_volume up ;;                              # Scroll up: Increase volume
5) change_volume down ;;                            # Scroll down: Decrease volume
esac

# ==========================================
# Display rendering
# ==========================================
print_format() {
  echo "$1" | envsubst '${SYMB}${VOL}${NAME}${MIC_SYMB}${MIC_NAME}'
}

print_block() {
  # --- 1. Fetch Sink (Speaker) Info ---
  local default_sink=$(pactl get-default-sink)
  local sink_info=$(pactl list sinks | awk -v sink="$default_sink" '
        $1 == "Name:" { active = ($2 == sink) }
        active { print $0 }
    ')

  if [[ -z "$sink_info" ]]; then
    echo "Sound inactive"
    echo '#222225'
    return
  fi

  VOL=$(echo "$sink_info" | grep -Po 'Volume: .*? \K\d+(?=%)' | head -n 1)
  MUTED=$(echo "$sink_info" | grep -Po 'Mute: \K(yes|no)')

  NAME=$(echo "$sink_info" | grep -Po 'node\.nick = "\K[^"]+' | head -n 1)
  if [[ -z "$NAME" ]]; then
    NAME=$(echo "$sink_info" | grep -Po 'Description: \K.*' || echo "$default_sink")
  fi

  if [[ "$MUTED" == "no" ]]; then
    SYMB=$AUDIO_HIGH_SYMBOL
    [[ $VOL -le $AUDIO_MED_THRESH ]] && SYMB=$AUDIO_MED_SYMBOL
    [[ $VOL -le $AUDIO_LOW_THRESH ]] && SYMB=$AUDIO_LOW_SYMBOL
    COLOR=$DEFAULT_COLOR
  else
    SYMB=$AUDIO_MUTED_SYMBOL
    COLOR=$MUTED_COLOR
  fi

  # --- 2. Fetch Source (Microphone) Info ---
  local default_source=$(pactl get-default-source)

  if [[ "$default_source" == *".monitor" ]]; then
    MIC_NAME="Off"
    MIC_SYMB=$MIC_OFF_SYMBOL
  else
    local source_info=$(pactl list sources | awk -v src="$default_source" '
            $1 == "Name:" { active = ($2 == src) }
            active { print $0 }
        ')

    MIC_MUTED=$(echo "$source_info" | grep -Po 'Mute: \K(yes|no)')
    MIC_NAME=$(echo "$source_info" | grep -Po 'node\.nick = "\K[^"]+' | head -n 1)
    if [[ -z "$MIC_NAME" ]]; then
      MIC_NAME=$(echo "$source_info" | grep -Po 'Description: \K.*' || echo "Mic")
    fi

    if [[ "$MIC_MUTED" == "no" ]]; then
      MIC_SYMB=$MIC_ON_SYMBOL
    else
      MIC_SYMB=$MIC_OFF_SYMBOL
    fi
  fi

  # --- 3. Output Render ---
  if [[ $SUBSCRIBE == 1 ]]; then
    print_format "$LONG_FORMAT"
  else
    print_format "$LONG_FORMAT"
    print_format "$SHORT_FORMAT"
    echo "$COLOR"
  fi
}

print_block

if [[ $SUBSCRIBE == 1 ]]; then
  while read -r EVENT; do
    print_block
  done < <(pactl subscribe | stdbuf -oL grep change)
fi
